/**********************************************
 *
 * filename:	atom.c
 * description: implement the atom operations
 * author:
 * date:		2019-09-27
 * version:		0.0.1
 *
 * interfaces:	atom_new atom_length atom_string atom_int
 *
 ***********************************************/

#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <limits.h>

#include "atom.h"

#define NELEMS(x)			((sizeof(x)) / (sizeof((x)[0])))

struct atom {
	struct atom *link;
	int len;
	char *str;
};

static struct atom *buckets[2048];

static unsigned long scatter[256] = {
1121892245,218623753,1685825244,1692225820,1395650214,
1053093803,685412681,1833808033,1379368312,308062485,
760458936,795744017,801943101,107373320,395767277,
696372838,805885700,2107609526,1176297248,1656533025,
276397951,963078297,2127714360,1941198309,1876170244,
407474018,888738028,1881400143,2046903520,423464600,
1029279666,1021312117,642088353,567621262,566054289,
2037738567,1620715065,1251466971,1724062953,852599730,
1559529456,337038241,1648343747,213988909,444411561,
2044111025,910361748,1250297261,2004236903,2086658996,
759346639,133151206,902253645,739577351,2074349516,
630940242,1147051369,815603896,364856737,1046471241,
1239068496,1394136403,2067783358,1881156849,1961757665,
486354000,1771411769,1434989083,1737820971,1347991074,
140105165,1149866779,1685029315,1788448912,1363855689,
2129440876,1685076289,126733789,1232254490,1541829544,
65909137,1991601129,1674980751,968162783,583694832,
1601846619,1599103025,1730746202,269966867,1963959762,
629733795,1509035364,1210612518,550033506,1242708565,
1024886535,1036387506,866636686,312391970,626724829,
67144112,452497135,1776591608,1752173427,93462400,
992963649,1734130656,1778538689,1119697438,818901498,
1172884586,1185606576,663018979,700381689,6285711,
1246713811,154744660,1605388736,829976365,424711527,
1421864850,1459710161,1933746891,484993720,2009743667,
1028971809,1509880256,898647525,1895608495,1822272226,
1525372354,1962752608,127285714,1154480314,1567442387,
220748114,2147443964,1154089395,1999286803,1119657754,
1972990893,1024687741,157780682,488526224,1725069430,
164066393,1735240036,1879814090,1769455129,417732753,
157041970,1043836332,1877442914,2090788861,1528830052,
1739702933,972277022,891226660,490866810,720401870,
566015239,2016239164,535670830,693300953,1023235831,
2103113217,914049067,1023196147,1109718965,765852222,
2142853901,935226210,1790539964,153150936,1423752435,
1368125746,317217329,1011508823,1100456189,2086672459,
1429241576,1257498159,983025143,1159200843,1200803372,
364371547,751420128,25596747,1255598208,1242286939,
745998617,1821613447,1111042455,1281669447,367430752,
2134278286,1237299016,1281479819,1009990785,199534333,
2047332041,1005361039,1134760544,1690388357,1158511975,
411029331,911030456,1475729304,1422538154,2011486645,
1414918115,704296082,1121501156,250459610,1863496925,
174820880,614831158,467433406,200417627,1870429366,
1709720345,946416244,1544559165,673279152,80602043,
1911989917,660073791,1317901060,1045986088,1670064576,
1517435393,945834481,527941967,504712289,488739191,
1686453942,915741620,1399769647,1014699599,190796126,
1263772644,282134066,895092209,237790152,532593677,
611105486,412611032,1147424835,1078538892,613028660,
870370553,640775589,1559444904,267446070,1314054742,
1640046948,
};

static char *long2str(char *str, int len, long n)
{
	unsigned long m;

	if (LONG_MIN == n)
		m = LONG_MAX + 1UL;
	else if (n < 0)
		m = -n;
	else
		m = n;

	do {
		str[--len] = m % 10 + '0';
	} while ((m /= 10) > 0);

	if (n < 0)
		str[--len] = '-';

	return str + len ;
}

int MODULE_FUN_NAME(atom, length)(const char *str)
{
	struct atom *p = NULL;
	int i;

	assert(str);

	for (i = 0; i < NELEMS(buckets); i++)
	{
		for (p = buckets[i]; p; p = p->link)
		{
			if (p->str == str)
				return p->len;
		}
	}

	assert(0);
	return 0;
}

const char *MODULE_FUN_NAME(atom, new)
	(const char *str, int len)
{
	unsigned long h;
	int i;
	struct atom *p = NULL;

	assert(str);
	assert(len >= 0);

	/* do hash and find the element index in @buckets */
	for (h = 0, i = 0; i < len; i++)
	{
		h = (h << 1) + scatter[(unsigned char)str[i]];
	}
	h &= NELEMS(buckets) - 1;

	for (p = buckets[h]; p; p = p->link)
	{
		if (len == p->len)
		{
			for (i = 0; i < len && p->str[i] == str[i]; i++)
				;
			if (i == len)
				return p->str;
		}
	}

	p = (struct atom *)calloc(1, sizeof(*p) + len + 1);
	if (NULL != p)
	{
		p->str = (char *)(p + 1);
		p->len = len;
		if (len > 0)
			memcpy(p->str, str, len);
		p->str[len] = '\0';
		p->link = buckets[h];
		buckets[h] = p;
	}

	return p->str;
}

const char *MODULE_FUN_NAME(atom, string)(const char *str)
{
	assert(str);

	return MODULE_FUN_NAME(atom, new)(str, strlen(str));
}

const char *MODULE_FUN_NAME(atom, int)(long n)
{
	char *p = NULL;
	char str[43] = { 0 };

	p = long2str(str, 43, n);

	return MODULE_FUN_NAME(atom, new)
			(p, sizeof(str) - (p - str));
}


/**** print interfaces *****/
#include <stdio.h>

void MODULE_FUN_NAME(atom, print)(void)
{
	int i;
	int count;
	struct atom *p = NULL;

	for (i = 0; i < NELEMS(buckets); i++)
	{
		count = 0;
		fprintf(stdout, "num: %d, count: %d\n", i, count);

		for (p = buckets[i]; p; p = p->link)
		{
			count++;
			fprintf(stdout, "p: %p, str: %s;", p, p->str);
			if (count % 5 == 0)
				fprintf(stdout, "\n");
		}

		fprintf(stdout, "num: %d, count: %d\n", i, count);
	}
}



